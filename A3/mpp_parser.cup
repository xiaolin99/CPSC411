/* CPSC441 - Assignment 3 */
/* by Xiao Lin */
/* Reference: http://www2.cs.tum.edu/projekte/cup/examples.php */
/*	      https://github.com/moy/JFlex/tree/master/jflex/examples */

import java_cup.runtime.*;
import java.io.*;

parser code {:
  public static void main(String[] args) {
    try {
      System.out.println("Parsing ["+args[0]+"]");
      // create a buffering scanner wrapper
      Scanner lexer = new mpp_lexor( new java.io.FileReader(args[0]));
      // start parsing
      parser p = new parser(lexer);
      p.parse();
    }
    catch (Exception e) {
	System.out.println("EXCEPTION");
    }
  }
:};

terminal ADD, SUB, MUL, DIV, ARROW;
terminal AND, OR, NOT;
terminal EQUAL, LT, GT, LE, GE;
terminal ASSIGN;
terminal LPAR, RPAR, CLPAR, CRPAR, SLPAR, SRPAR, SLASH;
terminal COLON, SEMICLON, COMMA;
terminal IF, THEN, WHILE, DO, READ, ELSE, BEGIN, END, CASE, OF, PRINT;
terminal INT, BOOL, CHAR, REAL, VAR, DATA, SIZE, FLOAT, FLOOR, CEIL;
terminal FUN, RETURN;
terminal CID, ID, RVAL, IVAL, BVAL, CVAL;

/* program */
non terminal prog, block;
/* declarations */
non terminal declarations, declaration, var_declaration;
non terminal var_specs, more_var_specs, var_spec, array_dimensions, type;
/* functions */
non terminal fun_declaration, fun_block;
non terminal param_list, parameters, more_parameters, basic_declaration, basic_array_dimensions;
/* polynomial inductive datatypes */
non terminal data_declaration;
non terminal cons_declarations, more_cons_decl, cons_decl;
non terminal type_list, more_type;
/* M statements */
non terminal program_body, fun_body;
non terminal prog_stmts, prog_stmt, location;
/* case statements */
non terminal case_list, more_case, case;
non terminal var_list, var_list1, more_var_list1;
/* expression */
non terminal expr, bint_term, bint_factor;
non terminal compare_op, int_expr, addop, int_term, mulop, int_factor;
/* modifier */
non terminal modifier_list;
non terminal fun_argument_list, cons_argument_list, arguments, more_arguments;

start with prog;


/* program */

prog		::= block
	;
block		::= declarations program_body
	;

/* declarations */

declarations	::= declaration SEMICLON declarations
		|
	;
declaration	::= var_declaration
		| fun_declaration
		| data_declaration
	;
var_declaration	::= VAR var_specs COLON type
	;
var_specs	::= var_spec more_var_specs
	;
more_var_specs	::= COMMA var_spec more_var_specs
		|
	;
var_spec	::= ID array_dimensions
	;
array_dimensions ::= SLPAR expr SRPAR array_dimensions
		|
	;
type		::= INT
		| REAL
		| BOOL
		| CHAR
		| ID
	;
/* functions */

fun_declaration	::= FUN ID param_list COLON type CLPAR fun_block CRPAR
	;
fun_block	::= declarations fun_body
	;
param_list	::= LPAR parameters RPAR
	;
parameters	::= basic_declaration more_parameters
		|
	;
more_parameters	::= COMMA basic_declaration more_parameters
		|
	;

basic_declaration ::= ID basic_array_dimensions COLON type
	;
basic_array_dimensions ::= SLPAR SRPAR basic_array_dimensions
		|
	;

/* polynomial */

data_declaration ::= DATA ID EQUAL cons_declarations
	;
cons_declarations ::= cons_decl more_cons_decl
	;
more_cons_decl	::= SLASH cons_decl more_cons_decl
		|
	;
cons_decl	::= CID OF type_list
		| CID
	;
type_list	::= type more_type
	;
more_type	::= MUL type more_type
		|
	;

/* M statements */

program_body	::= BEGIN prog_stmts END
		| prog_stmts
	;
fun_body	::= BEGIN prog_stmts RETURN expr SEMICLON END
		| prog_stmts RETURN expr SEMICLON
	;
prog_stmts	::= prog_stmt SEMICLON prog_stmts
		|
	;
prog_stmt	::= IF expr THEN prog_stmt ELSE prog_stmt
		| WHILE expr DO prog_stmt
		| READ location
		| location ASSIGN expr
		| PRINT expr
		| CLPAR block CRPAR
		| CASE expr OF CLPAR case_list CRPAR
	;
location	::= ID array_dimensions
	;

/* case */

case_list	::= case more_case
	;
more_case	::= SLASH case more_case
		|
	;
case		::= CID var_list ARROW prog_stmt
	;
var_list	::= LPAR var_list1 RPAR
		|
	;
var_list1	::= ID more_var_list1
	;
more_var_list1	::= COMMA ID more_var_list1
		|
	;


/* Expressions */

expr		::= expr OR bint_term
		| bint_term
	;
bint_term	::= bint_term AND bint_factor
		| bint_factor
	;
bint_factor	::= NOT bint_factor
		| int_expr compare_op int_expr
		| int_expr
	;
compare_op	::= EQUAL 
		| LT 
		| GT 
		| LE 
		| GE
	;
int_expr	::= int_expr addop int_term
		| int_term
	;
addop		::= ADD 
		| SUB
	;
int_term	::= int_term mulop int_factor
		| int_factor
	;
mulop		::= MUL 
		| DIV
	;
int_factor	::= LPAR expr RPAR
		| SIZE LPAR ID basic_array_dimensions RPAR
		| FLOAT LPAR expr RPAR
		| FLOOR LPAR expr RPAR
		| CEIL LPAR expr RPAR
		| ID modifier_list
		| CID cons_argument_list
		| IVAL
		| RVAL
		| BVAL
		| CVAL
		| SUB int_factor
	;

/* modifier */
modifier_list	::= fun_argument_list
		| array_dimensions
	;
fun_argument_list ::= LPAR arguments RPAR
	;
cons_argument_list ::= fun_argument_list
		|
	;
arguments	::= expr more_arguments
		|
	;
more_arguments	::= COMMA expr more_arguments
		|
	;


